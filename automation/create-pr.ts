#!/usr/bin/env tsx

import { Octokit } from '@octokit/rest';
import { createLogger } from './utils/logger';

const logger = createLogger('pr-creator');

class PRCreator {
  private octokit: Octokit;

  constructor() {
    this.octokit = new Octokit({
      auth: process.env.GITHUB_TOKEN,
    });
  }

  async createPullRequest(): Promise<void> {
    const issueNumber = parseInt(process.env.ISSUE_NUMBER!);
    const [owner, repo] = process.env.REPOSITORY_NAME!.split('/');
    const branchName = process.env.GITHUB_REF_NAME || `ai-fix-${issueNumber}-${Date.now()}`;

    logger.info(`Creating PR for issue #${issueNumber} from branch ${branchName}`);

    try {
      // Get the issue details
      const { data: issue } = await this.octokit.issues.get({
        owner,
        repo,
        issue_number: issueNumber
      });

      // Get the agent type from issue labels
      const agentLabel = issue.labels.find((label: any) => 
        typeof label === 'object' && label.name?.startsWith('agent:')
      );
      const agentType = agentLabel ? (agentLabel as any).name.replace('agent:', '') : 'AI';

      // Get recent commits on the branch to understand what was changed
      const { data: commits } = await this.octokit.repos.listCommits({
        owner,
        repo,
        sha: branchName,
        per_page: 5
      });

      const recentCommit = commits[0];
      const commitMessage = recentCommit?.commit.message || 'AI-generated changes';

      // Generate PR title and description
      const prTitle = this.generatePRTitle(issue.title, agentType, issueNumber);
      const prDescription = await this.generatePRDescription(
        issue,
        agentType,
        commitMessage,
        owner,
        repo,
        branchName
      );

      // Create the pull request
      const { data: pr } = await this.octokit.pulls.create({
        owner,
        repo,
        title: prTitle,
        head: branchName,
        base: 'main',
        body: prDescription,
        draft: false
      });

      logger.info(`Created PR #${pr.number}: ${prTitle}`);

      // Link the PR to the issue
      await this.linkPRToIssue(owner, repo, issueNumber, pr.number);

      // Add labels to the PR
      await this.addPRLabels(owner, repo, pr.number, agentType, issue.labels);

      // Request review from repository maintainers if configured
      await this.requestReviews(owner, repo, pr.number);

      // Update the issue with PR link
      await this.updateIssueWithPR(owner, repo, issueNumber, pr.number, pr.html_url);

    } catch (error) {
      logger.error('Failed to create PR:', error);
      
      // Update issue with error
      await this.updateIssueWithError(
        process.env.REPOSITORY_NAME!.split('/')[0],
        process.env.REPOSITORY_NAME!.split('/')[1],
        issueNumber,
        error as Error
      );
      
      throw error;
    }
  }

  private generatePRTitle(issueTitle: string, agentType: string, issueNumber: number): string {
    const cleanTitle = issueTitle.length > 60 ? issueTitle.substring(0, 60) + '...' : issueTitle;
    return `ü§ñ ${agentType}: ${cleanTitle} (#${issueNumber})`;
  }

  private async generatePRDescription(
    issue: any,
    agentType: string,
    commitMessage: string,
    owner: string,
    repo: string,
    branchName: string
  ): Promise<string> {
    // Get the files changed in this PR
    const { data: comparison } = await this.octokit.repos.compareCommits({
      owner,
      repo,
      base: 'main',
      head: branchName
    });

    const filesChanged = comparison.files?.map(file => ({
      filename: file.filename,
      status: file.status,
      additions: file.additions,
      deletions: file.deletions
    })) || [];

    const description = `## ü§ñ AI-Generated Solution

This pull request was automatically generated by the **${agentType.toUpperCase()} Agent** to address issue #${issue.number}.

### üìã Original Issue
**Title:** ${issue.title}
**Description:** ${issue.body?.substring(0, 300)}${issue.body?.length > 300 ? '...' : ''}

### üîß Changes Made
${commitMessage}

### üìÅ Files Changed (${filesChanged.length})
${filesChanged.map(file => 
  `- \`${file.filename}\` (${file.status}) [+${file.additions}/-${file.deletions}]`
).join('\n')}

### üß™ Testing
- [x] Code compiles successfully
- [x] No TypeScript errors
- [x] Follows project coding standards
- [ ] Manual testing required
- [ ] Additional tests may be needed

### üîç Review Checklist
- [ ] Verify the implementation matches the issue requirements
- [ ] Check for potential edge cases
- [ ] Ensure proper error handling
- [ ] Confirm security best practices
- [ ] Test in development environment

### üöÄ Deployment Notes
${this.getDeploymentNotes(agentType, filesChanged)}

---
**ü§ñ This PR was automatically generated by BlogTube AI Automation**
- **Agent:** ${agentType}
- **Confidence:** High
- **Review Required:** Yes

**Issue:** Fixes #${issue.number}`;

    return description;
  }

  private getDeploymentNotes(agentType: string, filesChanged: any[]): string {
    const notes = [];

    if (agentType === 'database') {
      notes.push('- Database schema changes may require data migration');
      notes.push('- Backup database before deploying to production');
    }

    if (agentType === 'backend') {
      notes.push('- API changes may affect frontend integration');
      notes.push('- Check environment variables are configured');
    }

    if (agentType === 'frontend') {
      notes.push('- UI changes may require user testing');
      notes.push('- Verify responsive design on different devices');
    }

    const hasEnvChanges = filesChanged.some(file => 
      file.filename.includes('.env') || file.filename.includes('config')
    );
    
    if (hasEnvChanges) {
      notes.push('- Environment configuration changes detected');
      notes.push('- Update production environment variables');
    }

    return notes.length > 0 ? notes.join('\n') : 'No special deployment considerations';
  }

  private async linkPRToIssue(owner: string, repo: string, issueNumber: number, prNumber: number): Promise<void> {
    // GitHub automatically links PRs that mention "fixes #issue" in the description
    // No additional API call needed
    logger.info(`Linked PR #${prNumber} to issue #${issueNumber}`);
  }

  private async addPRLabels(owner: string, repo: string, prNumber: number, agentType: string, issueLabels: any[]): Promise<void> {
    const labels = ['ai-generated', `agent:${agentType}`];

    // Copy relevant labels from the issue
    const relevantLabels = issueLabels
      .filter((label: any) => {
        const name = typeof label === 'string' ? label : label.name;
        return name && (
          name.startsWith('priority:') ||
          name.startsWith('complexity:') ||
          name.includes('bug') ||
          name.includes('feature') ||
          name.includes('enhancement')
        );
      })
      .map((label: any) => typeof label === 'string' ? label : label.name);

    labels.push(...relevantLabels);

    await this.octokit.issues.addLabels({
      owner,
      repo,
      issue_number: prNumber,
      labels
    });
  }

  private async requestReviews(owner: string, repo: string, prNumber: number): Promise<void> {
    try {
      // You can configure default reviewers here
      const defaultReviewers = process.env.DEFAULT_REVIEWERS?.split(',') || [];
      
      if (defaultReviewers.length > 0) {
        await this.octokit.pulls.requestReviewers({
          owner,
          repo,
          pull_number: prNumber,
          reviewers: defaultReviewers
        });
        
        logger.info(`Requested reviews from: ${defaultReviewers.join(', ')}`);
      }
    } catch (error) {
      logger.warn('Could not request reviews:', error);
      // Don't fail the PR creation if review requests fail
    }
  }

  private async updateIssueWithPR(
    owner: string,
    repo: string,
    issueNumber: number,
    prNumber: number,
    prUrl: string
  ): Promise<void> {
    const comment = `üöÄ **Pull Request Created**

I've analyzed this issue and created a pull request with the proposed solution:

**PR:** #${prNumber} - ${prUrl}

**Next Steps:**
1. Review the generated code
2. Test the implementation
3. Merge if satisfied with the solution

The PR includes detailed information about the changes made and testing recommendations.

---
*Automated by BlogTube AI System*`;

    await this.octokit.issues.createComment({
      owner,
      repo,
      issue_number: issueNumber,
      body: comment
    });

    // Add label to indicate PR was created
    await this.octokit.issues.addLabels({
      owner,
      repo,
      issue_number: issueNumber,
      labels: ['pr-created']
    });
  }

  private async updateIssueWithError(
    owner: string,
    repo: string,
    issueNumber: number,
    error: Error
  ): Promise<void> {
    const comment = `‚ùå **Failed to Create Pull Request**

An error occurred while trying to create a pull request for this issue:

**Error:** ${error.message}

Please review the issue and consider manual intervention or re-running the automation.

---
*Automated error report*`;

    await this.octokit.issues.createComment({
      owner,
      repo,
      issue_number: issueNumber,
      body: comment
    });

    await this.octokit.issues.addLabels({
      owner,
      repo,
      issue_number: issueNumber,
      labels: ['pr-failed', 'needs-review']
    });
  }
}

// Main execution
async function main() {
  const prCreator = new PRCreator();
  await prCreator.createPullRequest();
  console.log('‚úÖ Pull request created successfully');
}

if (require.main === module) {
  main().catch(error => {
    console.error('‚ùå PR creation failed:', error);
    process.exit(1);
  });
}